<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Caça Palavras da Privacidade</title>
  <style>
    :root {
      --radius: 12px;
      --gap: 2px;
      --bg-overlay: rgba(255,255,255,.55);
      --brand: #0000CC;
      --ok: #0f0;
      --ui: #f0f0f0;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background-image: url('https://storyboardppd.github.io/hq/fundo/tabuleiro.jpg');
      background-size: cover;
      background-attachment: scroll; /* melhor para iOS */
      background-position: center;
      color: #222;
      -webkit-text-size-adjust: 100%;
    }

    header {
      background: var(--ui);
      padding: 12px 16px;
      display: grid;
      grid-template-columns: auto 1fr;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid #ccc;
    }

    header img {
      width: 44px;
      height: auto;
    }

    header h1 {
      margin: 0;
      font-size: clamp(18px, 2.6vw, 26px);
      color: var(--brand);
      line-height: 1.2;
    }

    .game-container {
      max-width: 1100px;
      margin: 16px auto 24px;
      padding: 12px;
      background: var(--bg-overlay);
      border-radius: var(--radius);
      backdrop-filter: blur(2px);
    }

    .buttons { text-align: center; margin-bottom: 12px; }

    button {
      padding: 12px 18px;
      font-size: 16px;
      border-radius: 10px;
      border: none;
      background: #1b7e1b;
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      touch-action: manipulation;
    }
    button:active { transform: translateY(1px); }

    .game-area {
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 16px;
      align-items: start;
    }

    /* GRID RESPONSIVO: 22 colunas, células quadradas via aspect-ratio */
    #wordGrid {
      display: grid;
      grid-template-columns: repeat(22, 1fr);
      gap: var(--gap);
      background: #ccc;
      padding: var(--gap);
      border-radius: 8px;
      width: 100%;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none; /* evita scroll durante a seleção */
    }

    .cell {
      display: grid;
      place-items: center;
      background: rgba(200,200,200, .4);
      border: 1px solid #c9c9c9;
      font-weight: 600;
      aspect-ratio: 1 / 1; /* torna quadrado em qualquer largura */
      font-size: clamp(10px, 2.2vw, 16px);
      -webkit-tap-highlight-color: transparent;
    }

    .cell.selected { background-color: #666; color: #0f0; }
    .cell.correct  { background-color: var(--ok); color: #000; }

    #wordList {
      list-style: none;
      margin: 0;
      background: var(--bg-overlay);
      padding: 12px;
      border-radius: 8px;
      max-height: 70vh;
      overflow: auto;
    }
    #wordList h2 { margin: 0 0 8px; font-size: 18px; }
    .word { margin: 6px 0; font-size: 16px; }
    .word.found { text-decoration: line-through; color: #d00; }

    #wordCounter { text-align: center; font-size: 16px; margin: 6px 0 12px; }

    .popup {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 1000;
      background: rgba(0,0,0,.45);
      padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom);
    }

    .popup-content {
      background: #FFD65A;
      margin: 6vh auto;
      padding: 20px;
      border-radius: var(--radius);
      border: 1px solid #888;
      width: min(92vw, 820px);
      max-height: 80vh;
      overflow: auto;
    }

    .explanation-text { margin-top: 12px; }
    #wordExplanations { padding-left: 18px; }
    #wordExplanations li { margin-bottom: 8px; }

    footer {
      background: var(--ui);
      padding: 12px 16px;
      text-align: left;
      border-top: 1px solid #ccc;
    }

    /* Tooltip acessível para toque (aparece também com foco) */
    .tooltip { position: relative; display: inline-block; }
    .tooltip .tooltiptext {
      position: absolute;
      left: 50%; transform: translateX(-50%);
      bottom: calc(100% + 8px);
      width: 220px; text-align: center;
      padding: 6px 8px; border-radius: 6px; color: #fff; background: #0099FF;
      opacity: 0; visibility: hidden; transition: opacity .2s;
      pointer-events: none;
    }
    .tooltip:focus-within .tooltiptext,
    .tooltip:hover .tooltiptext { opacity: 1; visibility: visible; }

    /* MOBILE: empilha grid e lista; aumenta fontes e espaçamentos */
    @media (max-width: 768px) {
      .game-area { grid-template-columns: 1fr; }
      #wordList { max-height: none; }
      header { grid-template-columns: auto 1fr; }
      header img { width: 40px; }
      footer { position: static; }
    }
  </style>
</head>
<body>
  <header>
    <img src="https://storyboardppd.github.io/hq/marca-serpro.png" alt="Logo Serpro" />
    <h1>Caça Palavras da Privacidade — Newsletter Setembro/2025</h1>
  </header>

  <main class="game-container">
    <div class="buttons">
      <span class="tooltip">
        <button id="startButton" aria-describedby="dica">Iniciar Jogo</button>
        <span role="tooltip" id="dica" class="tooltiptext">Toque e arraste o dedo (ou o mouse) para selecionar</span>
      </span>
    </div>

    <div id="wordCounter" aria-live="polite">Palavras restantes: 10</div>

    <section class="game-area">
      <div id="wordGrid" aria-label="Tabuleiro do caça-palavras" role="grid"></div>
      <aside id="wordList" aria-label="Lista de Palavras">
        <h2>Lista de Palavras</h2>
      </aside>
    </section>
  </main>

  <div id="completionPopup" class="popup" role="dialog" aria-modal="true" aria-labelledby="popupTitle">
    <div class="popup-content">
      <h2 id="popupTitle">Parabéns!</h2>
      <p>Você encontrou todas as palavras relacionadas à Privacidade e Proteção de Dados!</p>
      <div class="explanation-text">
        <h3>Significado das palavras encontradas:</h3>
        <ul id="wordExplanations"></ul>
      </div>
      <button id="closePopup">Fechar</button>
    </div>
  </div>

  <footer>
    &copy; 2025 Departamento de Privacidade e Proteção de Dados Pessoais.
  </footer>

  <script>
    const words = [
                    "DADOSENSIVEL", "EXPLOT", "IDENTIDADEDIGITAL", "METADADOS",
                    "PSEUDONIMIZACAO","QUALIDADE", "REVISAO", "SEGURANCA", "SISTEMAS",
                    "VPN"
    ];

    const wordExplanations = {
                           "DADOSENSIVEL": "Informações que, se divulgadas, podem causar danos graves à pessoa, como origem racial, religião, saúde, orientação sexual, entre outros.",
                           "EXPLOT": "Abreviação de exploração, ação de tirar proveito de uma vulnerabilidade.",
                           "IDENTIDADEDIGITAL": "Conjunto de informações e atributos online que representam uma pessoa na internet, incluindo contas, dados e atividades.",
                           "METADADOS": "São informações que acrescem aos dados e que têm como objetivo informar-nos sobre eles para tornar mais fácil a sua organização.",
                           "PSEUDONIMIZACAO": "Substituição de dados pessoais por pseudônimos para proteger a identidade do indivíduo.",
                           "QUALIDADE": "Princípio que assegura a exatidão e atualização das informações pessoais.",
                           "REVISAO": "Direito de questionar decisões tomadas por IA.",
                           "SEGURANCA": "Ações tomadas para proteger dados e sistemas de acessos ou modificações não autorizadas.",
                           "SISTEMAS": "Conjunto de tecnologias, hardware e software que gerenciam dados pessoais e a sua segurança.",
                           "VPN": "Rede Privada Virtual é uma tecnologia que cria uma conexão segura e criptografada entre o usuário e a internet, protegendo a privacidade online."
                         };

    const gridSize = 22;
    let grid = [];
    let selectedCells = [];
    let foundWords = [];
    let remainingWords = words.length;

    function initializeGrid() {
      grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(''));
    }

    function placeWords() {
      initializeGrid();
      const shuffled = [...words].sort(() => Math.random() - 0.5);
      const horizontalWords = shuffled.slice(0, 5);
      const verticalWords = shuffled.slice(5);

      horizontalWords.forEach(w => placeWordRandomly(w, true));
      verticalWords.forEach(w => placeWordWithIntersection(w, horizontalWords));

      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (!grid[i][j]) grid[i][j] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
        }
      }
    }

    function placeWordRandomly(word, isHorizontal) {
      let placed = false, attempts = 0; const MAX = 200;
      while (!placed && attempts < MAX) {
        const row = Math.floor(Math.random() * (isHorizontal ? gridSize : (gridSize - word.length + 1)));
        const col = Math.floor(Math.random() * (isHorizontal ? (gridSize - word.length + 1) : gridSize));
        if (canPlaceWord(word, row, col, isHorizontal)) {
          for (let i = 0; i < word.length; i++) {
            if (isHorizontal) grid[row][col + i] = word[i]; else grid[row + i][col] = word[i];
          }
          placed = true;
        }
        attempts++;
      }
      if (!placed) console.error('Não foi possível colocar a palavra:', word);
    }

    function placeWordWithIntersection(word, horizontalWords) {
      let placed = false, attempts = 0; const MAX = 200;
      while (!placed && attempts < MAX) {
        const intersectWord = horizontalWords[Math.floor(Math.random() * horizontalWords.length)];
        const intersectChar = word.split('').find(c => intersectWord.includes(c));
        if (intersectChar) {
          const iColH = intersectWord.indexOf(intersectChar);
          const iRowV = word.indexOf(intersectChar);
          const hRow = findWordRow(intersectWord);
          if (hRow !== -1) {
            const col = grid[hRow].indexOf(intersectWord[0]) + iColH;
            const row = Math.max(0, Math.min(gridSize - word.length, hRow - iRowV));
            if (canPlaceWord(word, row, col, false)) {
              for (let i = 0; i < word.length; i++) grid[row + i][col] = word[i];
              placed = true;
            }
          }
        }
        attempts++;
      }
      if (!placed) placeWordRandomly(word, false);
    }

    function findWordRow(word) {
      for (let i = 0; i < gridSize; i++) if (grid[i].join('').includes(word)) return i; return -1;
    }

    function canPlaceWord(word, row, col, isHorizontal) {
      for (let i = 0; i < word.length; i++) {
        const r = isHorizontal ? row : row + i;
        const c = isHorizontal ? col + i : col;
        if (r >= gridSize || c >= gridSize) return false;
        if (grid[r][c] && grid[r][c] !== word[i]) return false;
      }
      return true;
    }

    function createGrid() {
      const wordGrid = document.getElementById('wordGrid');
      wordGrid.innerHTML = '';
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.textContent = grid[i][j];
          cell.dataset.row = i;
          cell.dataset.col = j;
          cell.setAttribute('role', 'gridcell');
          wordGrid.appendChild(cell);
        }
      }
    }

    function createWordList() {
      const ul = document.getElementById('wordList');
      ul.innerHTML = '<h2>Lista de Palavras</h2>';
      words.forEach(w => {
        const div = document.createElement('div');
        div.className = 'word';
        div.textContent = w;
        ul.appendChild(div);
      });
    }

    let isSelecting = false;
    let selectionStart = null;

    // Seleção com Pointer Events (unifica mouse + toque)
    function attachPointerSelection() {
      const gridEl = document.getElementById('wordGrid');

      gridEl.addEventListener('pointerdown', (e) => {
        const cell = e.target.closest('.cell');
        if (!cell) return;
        isSelecting = true;
        selectionStart = cell;
        selectPathTo(cell);
        try { gridEl.setPointerCapture(e.pointerId); } catch {}
      });

      gridEl.addEventListener('pointermove', (e) => {
        if (!isSelecting) return;
        const el = document.elementFromPoint(e.clientX, e.clientY);
        const cell = el && el.closest && el.closest('.cell');
        if (cell) selectPathTo(cell);
      });

      function finishSelection() {
        if (!isSelecting) return;
        isSelecting = false;
        checkSelectedWord();
      }

      gridEl.addEventListener('pointerup', finishSelection);
      gridEl.addEventListener('pointercancel', finishSelection);
      gridEl.addEventListener('pointerleave', (e) => { if (isSelecting) finishSelection(); });
    }

    function selectPathTo(cell) {
      if (!cell || !selectionStart) return;
      const startRow = parseInt(selectionStart.dataset.row);
      const startCol = parseInt(selectionStart.dataset.col);
      const currentRow = parseInt(cell.dataset.row);
      const currentCol = parseInt(cell.dataset.col);

      // limpa seleção anterior
      selectedCells.forEach(c => {
        const el = document.querySelector(`[data-row="${c.row}"][data-col="${c.col}"]`);
        el && el.classList.remove('selected');
      });
      selectedCells = [];

      // Seleciona em linha reta (H, V, D)
      if (startRow === currentRow || startCol === currentCol || Math.abs(startRow - currentRow) === Math.abs(startCol - currentCol)) {
        const rowStep = Math.sign(currentRow - startRow) || 0;
        const colStep = Math.sign(currentCol - startCol) || 0;
        let r = startRow, c = startCol;
        while (true) {
          const el = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
          if (el) {
            el.classList.add('selected');
            selectedCells.push({ row: r, col: c, letter: el.textContent });
          }
          if (r === currentRow && c === currentCol) break;
          r += rowStep; c += colStep;
        }
      }
    }

    function checkSelectedWord() {
      const selectedWord = selectedCells.map(c => c.letter).join('');
      const reversedWord = [...selectedWord].reverse().join('');
      const found = words.find(w => w === selectedWord || w === reversedWord);

      if (found && !foundWords.includes(found)) {
        foundWords.push(found);
        remainingWords--;
        updateWordCounter();
        document.querySelectorAll('.word').forEach(w => { if (w.textContent === found) w.classList.add('found'); });
        selectedCells.forEach(c => {
          const el = document.querySelector(`[data-row="${c.row}"][data-col="${c.col}"]`);
          el && (el.classList.add('correct'), el.classList.remove('selected'));
        });
        if (remainingWords === 0) showCompletionPopup();
      } else {
        selectedCells.forEach(c => {
          const el = document.querySelector(`[data-row="${c.row}"][data-col="${c.col}"]`);
          el && el.classList.remove('selected');
        });
      }
      selectedCells = [];
    }

    function updateWordCounter() {
      document.getElementById('wordCounter').textContent = `Palavras restantes: ${remainingWords}`;
    }

    function showCompletionPopup() {
      const popup = document.getElementById('completionPopup');
      const list = document.getElementById('wordExplanations');
      list.innerHTML = '';
      foundWords.forEach(w => {
        const li = document.createElement('li');
        li.innerHTML = `<strong>${w}</strong>: ${wordExplanations[w]}`;
        list.appendChild(li);
      });
      popup.style.display = 'block';
    }

    function closeCompletionPopup() {
      document.getElementById('completionPopup').style.display = 'none';
    }

    function startGame() {
      placeWords();
      createGrid();
      createWordList();
      foundWords = [];
      selectedCells = [];
      remainingWords = words.length;
      updateWordCounter();
    }

    document.getElementById('startButton').addEventListener('click', startGame);
    document.getElementById('closePopup').addEventListener('click', closeCompletionPopup);

    // Init
    initializeGrid();
    placeWords();
    createGrid();
    createWordList();
    attachPointerSelection();
    updateWordCounter();
  </script>
</body>
</html>
